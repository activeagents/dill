# Tracks content transformations through AI agent interactions.
#
# AgentFragment represents a discrete piece of content that has been:
# - Selected by the user for AI processing
# - Generated by an AI agent
# - Applied (or discarded) in the document
#
# This enables version history tracking similar to Google Docs suggestions,
# allowing users to see what was changed and revert if needed.
#
class AgentFragment < ApplicationRecord
  belongs_to :agent_context
  belongs_to :contextable, polymorphic: true, optional: true

  # Version chain: fragments can link to parent fragments for history
  belongs_to :parent_fragment, class_name: "AgentFragment", optional: true
  has_many :child_fragments, class_name: "AgentFragment", foreign_key: :parent_fragment_id

  # Status enum for lifecycle tracking
  enum :status, {
    pending: "pending",
    generating: "generating",
    generated: "generated",
    applied: "applied",
    discarded: "discarded"
  }, default: :pending

  # Fragment types
  enum :fragment_type, {
    selection: "selection",
    full_document: "full_document"
  }, prefix: true

  # Validations
  validates :action_type, presence: true
  validates :original_content, presence: true

  # Callbacks
  before_create :compute_content_hash

  # Scopes
  scope :recent, -> { order(created_at: :desc) }
  scope :for_page, ->(page) { where(contextable: page) }
  scope :with_generations, -> { where.not(generated_content: nil) }
  scope :active, -> { where.not(status: :discarded) }

  # Compute SHA256 hash of original content for change detection
  def compute_content_hash
    self.content_hash = Digest::SHA256.hexdigest(original_content.to_s)
  end

  # Mark fragment as currently generating
  def mark_generating!
    update!(status: :generating)
  end

  # Mark fragment as generated with AI content
  def mark_generated!(content)
    update!(
      generated_content: content,
      status: :generated
    )
  end

  # Mark fragment as applied to the document
  def mark_applied!(final_content = nil)
    update!(
      applied_content: final_content || generated_content,
      status: :applied
    )
  end

  # Mark fragment as discarded
  def mark_discarded!
    update!(status: :discarded)
  end

  # Get the full version history chain
  def version_history
    chain = [self]
    current = self

    # Walk up the parent chain
    while current.parent_fragment
      current = current.parent_fragment
      chain.unshift(current)
    end

    chain
  end

  # Check if this fragment has any detected references
  def has_references?
    detected_references.present? && detected_references.any?
  end

  # Get accepted references from the detected_references JSON
  def accepted_references
    return [] unless detected_references.present?

    detected_references.select { |ref| ref["accepted"] != false }
  end

  # Get rejected references from the detected_references JSON
  def rejected_references
    return [] unless detected_references.present?

    detected_references.select { |ref| ref["accepted"] == false }
  end

  # Create a child fragment for regeneration with different settings
  def regenerate_with(new_references: nil, new_action_type: nil)
    child_fragments.create!(
      agent_context: agent_context,
      contextable: contextable,
      fragment_type: fragment_type,
      original_content: original_content,
      start_offset: start_offset,
      end_offset: end_offset,
      action_type: new_action_type || action_type,
      detected_references: new_references || detected_references,
      status: :pending
    )
  end

  # Human-readable action label
  def action_label
    action_type&.titleize || "Unknown"
  end

  # Short preview of original content
  def original_preview(length: 100)
    return "" unless original_content

    original_content.truncate(length)
  end

  # Short preview of generated content
  def generated_preview(length: 100)
    return "" unless generated_content

    generated_content.truncate(length)
  end

  # Check if content was modified from generated to applied
  def was_modified_on_apply?
    applied_content.present? && applied_content != generated_content
  end
end
