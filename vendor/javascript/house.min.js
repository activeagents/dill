function isString(value) {
  return "string" == typeof value;
}

function dispatchEvent(element, eventName, detail = null, cancelable = false) {
  return element.dispatchEvent(new CustomEvent(eventName, {
    bubbles: true,
    detail: detail,
    cancelable: cancelable
  }));
}

class Toolbar extends HTMLElement {
  constructor() {
    super();
  }

  connectedCallback() {
    this.#initializeToolbar();
    this.addEventListener("click", this.#handleClick);
    this.#getFilePicker()?.addEventListener("change", this.#handleFileChange);
  }

  disconnectedCallback() {
    this.#getFilePicker()?.removeEventListener("change", this.#handleFileChange);
    this.removeEventListener("click", this.#handleClick);
  }

  get #getFilePicker() {
    return this.querySelector("[data-house-md-toolbar-file-picker]");
  }

  #initializeToolbar() {
    this.#shouldRenderToolbar() && (this.innerHTML = this.#getToolbarHTML());
  }

  #handleClick = (event) => {
    const action = event.target.closest("[data-house-md-action]")?.dataset?.houseMdAction;
    if (action) {
      event.preventDefault();
      dispatchEvent(this, "house-md:toolbar-action", { houseMdAction: action });
    }
  };

  #handleFileChange = (event) => {
    for (const file of event.target.files) {
      dispatchEvent(this, "house-md:toolbar-action", {
        houseMdAction: "uploadFile",
        file: file
      });
    }
  };

  #shouldRenderToolbar() {
    return 0 === this.children.length;
  }

  #getToolbarHTML() {
    return `
      <button data-house-md-action="bold" title="Bold">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="m4.1 23c-.5 0-.7-.4-.7-.7v-20.6c0-.4.4-.7.7-.7h8.9c2 0 3.8.6 4.9 1.5 1.2 1 1.8 2.4 1.8 4.1s-.9 3.2-2.3 4.1c-.2 0-.3.3-.3.5s0 .4.3.5c1.9.8 3.2 2.7 3.2 5s-.7 3.6-2.1 4.7-3.3 1.7-5.6 1.7h-8.8zm4.2-18.1v5.1h3c1.2 0 2-.3 2.7-.7.6-.5.9-1.1.9-1.9s-.3-1.4-.8-1.8-1.3-.6-2.3-.6-2.4 0-3.5 0zm0 8.5v5.8h3.7c1.3 0 2.2-.3 2.8-.7s.9-1.2.9-2.2-.4-1.7-1-2.1-1.7-.7-2.9-.7-2.4 0-3.5 0z" fill-rule="evenodd"/></svg>
      </button>
      <button data-house-md-action="italic" title="Italic">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="m9.3 1h10.2v3.1h-3.5l-3.7 15.7h3.2v3.2h-11v-3.1h3.8l3.7-15.7h-2.8v-3.2z" fill-rule="evenodd"/></svg>
      </button>
      <button data-house-md-action="quote" title="Quote">
        <svg viewBox="0 0 24 22" xmlns="http://www.w3.org/2000/svg"><path d="m1.1 5.2c.6-.7 1.4-1.3 2.4-1.4 2.6-.4 4.2.4 5.3 1.9 2 2.3 1.9 5.1.6 7.6-1.3 2.4-4 4.6-7.2 5.1-.4 0-.7-.1-1-.4-.1-.3-.1-.7.3-1.1l1.1-1.1c.3-.4.6-.7.7-1.1s.3-.9 0-1.3c0-.4-.6-.7-1-1-1.2-.8-2.3-2.2-2.3-4.1.1-1.4.4-2.4 1.1-3.1z"/><path d="m14.6 5.2c.6-.7 1.6-1.1 2.6-1.4 2.4-.4 4.2.4 5.3 1.9 2 2.3 1.9 5.1.6 7.6-1.3 2.4-4 4.6-7.2 5.1-.4 0-.7-.1-1-.4-.1-.3-.1-.7.3-1.1l1.1-1.1c.3-.4.6-.7.7-1.1s.3-.9 0-1.3c-.1-.4-.6-.7-1-1-1.3-.6-2.4-2-2.4-3.9s.4-2.6 1-3.3z"/></svg>
      </button>
      <button data-house-md-action="code" title="Code">
        <svg viewBox="0 0 24 22" xmlns="http://www.w3.org/2000/svg"><path d="m.4 10.1c-.5.5-.5 1.4 0 1.9l5.3 5.3c.5.5 1.4.5 1.9 0s.5-1.4 0-1.9l-4.4-4.4 4.4-4.4c.5-.5.5-1.4 0-1.9s-1.3-.5-1.9 0c0 0-5.3 5.4-5.3 5.4zm17.9 7.2 5.3-5.3c.5-.5.5-1.4 0-1.9l-5.3-5.3c-.5-.5-1.4-.5-1.9 0s-.5 1.4 0 1.9l4.4 4.4-4.4 4.4c-.5.5-.5 1.4 0 1.9.5.4 1.4.4 1.9-.1z" fill-rule="evenodd"/></svg>
      </button>
      <button data-house-md-action="link" title="Link">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="m9.4 14.5c-2.3-2.3-2.3-5.9 0-8.2l4.6-4.6c1.1-1 2.6-1.7 4.2-1.7s3 .5 4.1 1.7c2.3 2.3 2.3 5.9 0 8.2l-2.7 2.3c-.5.5-1.2.5-1.8 0-.5-.5-.5-1.2 0-1.7l2.7-2.3c1.4-1.3 1.4-3.4 0-4.7-.7-.7-1.5-.9-2.3-.9s-1.8.4-2.5.9l-4.7 4.5c-1.4 1.3-1.4 3.4 0 4.7.5.5.5 1.2 0 1.7-.1.3-.4.4-.8.4s-.5-.1-.8-.3z"/><path d="m1.7 22.3c-2.3-2.3-2.3-5.9 0-8.2l2.6-2.5c.5-.5 1.2-.5 1.8 0 .5.5.5 1.2 0 1.7l-2.6 2.5c-1.4 1.3-1.4 3.4 0 4.7.7.7 1.5.9 2.3.9s1.8-.4 2.3-.9l4.6-4.6c1.4-1.3 1.4-3.4 0-4.7-.5-.4-.5-1.2 0-1.7s1.2-.5 1.8 0c2.3 2.3 2.3 5.9 0 8.2l-4.6 4.6c-1 1-2.5 1.7-4.1 1.7s-3-.7-4.1-1.7z"/></svg>
      </button>
      <button data-house-md-action="bulletList" title="Bullet list">
        <svg viewBox="0 0 24 22" xmlns="http://www.w3.org/2000/svg"><path d="m2.1 4.8c1.1 0 2.1-.9 2.1-2.1s-1-2-2.1-2-2.1.9-2.1 2.1.9 2 2.1 2zm4.1-2c0-.8.6-1.4 1.4-1.4h15.1c.7 0 1.3.6 1.3 1.4s-.6 1.4-1.4 1.4h-15.1c-.7 0-1.3-.7-1.3-1.4zm1.3 6.8c-.8 0-1.4.6-1.4 1.4s.6 1.4 1.4 1.4h15.1c.8 0 1.4-.6 1.4-1.4s-.6-1.4-1.4-1.4zm0 8.3c-.8 0-1.4.6-1.4 1.4s.6 1.4 1.4 1.4h15.1c.8 0 1.4-.6 1.4-1.4s-.6-1.4-1.4-1.4zm-3.4-6.9c0 1.1-.9 2.1-2.1 2.1s-2-1-2-2.1.9-2.1 2.1-2.1 2 1 2 2.1zm-2 10.3c1.1 0 2.1-.9 2.1-2.1s-.9-2.1-2.1-2.1-2.1 1-2.1 2.1.9 2.1 2.1 2.1z" fill-rule="evenodd"/></svg>
      </button>
      <button data-house-md-action="numberList" title="Numbered list">
        <svg viewBox="0 0 24 22" xmlns="http://www.w3.org/2000/svg"><path d="m0 .3h2.7v5.3h-1.4v-4h-1.3zm6.7 2.7c0-.7.6-1.3 1.3-1.3h14.7c.7 0 1.3.6 1.3 1.3s-.6 1.3-1.3 1.3h-14.7c-.7 0-1.3-.6-1.3-1.3zm1.3 6.7c-.7 0-1.3.6-1.3 1.3s.6 1.3 1.3 1.3h14.7c.7 0 1.3-.6 1.3-1.3s-.6-1.3-1.3-1.3zm0 8c-.7 0-1.3.6-1.3 1.3s.6 1.3 1.3 1.3h14.7c.7 0 1.3-.6 1.3-1.3s-.6-1.3-1.3-1.3zm-4.7-9.4h.7v1.3l-2 2.7h2v1.3h-4v-1.3l2.2-2.7h-2.2v-1.3zm-3.3 9.4v-1.3h4v5.3h-4v-1.3h2.7v-.7h-1.4v-1.3h1.3v-.7z" fill-rule="evenodd"/></svg>
      </button>
      <label title="Add Image">
        <svg viewBox="0 0 24 20" xmlns="http://www.w3.org/2000/svg"><path d="m22 20h-20c-1.1 0-2-.9-2-2.1v-15.8c0-1.2.9-2.1 2-2.1h20c1.1 0 2 .9 2 2.1v15.8c0 1.1-.9 2.1-2 2.1zm0-2.9v-14.5c0-.3-.2-.5-.5-.5h-19c-.3 0-.5.2-.5.5v14.5c0 .1.1.2.2.2s.2 0 .2-.1l2.2-3.3c.1-.2.3-.3.5-.3h.7l2.6-4c.1-.2.3-.3.5-.3h.7c.2 0 .4.1.5.3l5.3 8c0 .1.2.2.3.2h.3c.2 0 .4-.2.4-.4s0-.2 0-.2l-1.3-1.9c-.2-.2-.2-.6 0-.8l1.2-1.6c.1-.2.3-.3.5-.3h1.1c.2 0 .4 0 .5.3l3.2 4.4c0 .1.3.2.4 0 .2 0 .2 0 .2-.2zm-5.5-7.6c-1.4 0-2.5-1.2-2.5-2.6s1.1-2.6 2.5-2.6 2.5 1.2 2.5 2.6-1.1 2.6-2.5 2.6z" fill-rule="evenodd"/></svg>
        <input type="file" data-house-md-toolbar-file-picker multiple style="display: none;">
      </label>`;
  }
}

customElements.define("house-md-toolbar", Toolbar);

class Selection {
  start = 0;
  end = 0;

  static fromDOMRange(range, container) {
    const { startOffset, startContainer, endOffset, endContainer } = range;
    const start = getTextOffset(container, startContainer, startOffset);
    
    if (range.collapsed) {
      return new Selection(container, start, start);
    }
    
    const end = getTextOffset(container, endContainer, endOffset);
    return new Selection(container, start, end);
  }

  constructor(container, start, end) {
    this.container = container;
    this.start = start;
    this.end = end;
  }

  toDOMRange() {
    const range = document.createRange();
    range.setStart(this.container, 1);
    range.setEnd(this.container, this.container.childNodes.length);
    
    const walker = document.createTreeWalker(this.container, NodeFilter.SHOW_TEXT);
    let offset = 0;
    let startSet = false;
    let endSet = false;
    
    while (walker.nextNode() && (!startSet || !endSet)) {
      const textLength = walker.currentNode.textContent.length;
      
      if (offset + textLength >= this.start && !startSet) {
        startSet = true;
        range.setStart(walker.currentNode, this.start - offset);
      }
      
      if (offset + textLength >= this.end && !endSet) {
        endSet = true;
        range.setEnd(walker.currentNode, this.end - offset);
      }
      
      offset += textLength;
    }
    
    return range;
  }

  isEqual(other) {
    return this.container === other.container && 
           this.start === other.start && 
           this.end === other.end;
  }
}

function getTextOffset(container, node, offset) {
  if (node.nodeType === Node.ELEMENT_NODE) {
    return getElementTextOffset(container, node, offset);
  } else {
    return getTextNodeOffset(container, node, offset);
  }
}

function getElementTextOffset(container, element, childIndex) {
  const targetChild = element.childNodes[childIndex];
  let textOffset = 0;
  const walker = document.createTreeWalker(container);
  
  while (walker.nextNode()) {
    if (walker.currentNode === targetChild) {
      return textOffset;
    }
    if (walker.currentNode.nodeType === Node.TEXT_NODE) {
      textOffset += walker.currentNode.textContent.length;
    }
  }
  
  return textOffset;
}

function getTextNodeOffset(container, textNode, offset) {
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT);
  
  while (walker.nextNode()) {
    if (walker.currentNode === textNode) {
      return offset;
    }
    offset += walker.currentNode.textContent.length;
  }
  
  return offset;
}

class SelectionManager {
  #document;
  #selection;
  #selectionText;

  constructor(document) {
    this.#document = document;
    this.#selection = new Selection(this.contentElement, 0, 0);
    this.#selectionText = "";
  }

  current() {
    return {
      start: this.start,
      end: this.end,
      selection: this.#selectionText
    };
  }

  currentLine() {
    return this.lineAt(this.end);
  }

  previousLine() {
    const { content } = this.#document;
    const lineStart = Math.max(content.lastIndexOf("\n", this.start - 1), 0);
    return this.lineAt(lineStart);
  }

  lineAt(position) {
    const { content } = this.#document;
    const lineStart = Math.max(content.lastIndexOf("\n", position - 1) + 1, 0);
    const lineEndIndex = content.indexOf("\n", position);
    const lineEnd = -1 === lineEndIndex ? content.length : lineEndIndex + 1;
    
    return {
      start: lineStart,
      end: lineEnd,
      content: content.slice(lineStart, lineEnd)
    };
  }

  select({ start, end }) {
    this.documentRange = new Selection(this.contentElement, start, end);
    const domRange = this.documentRange.toDOMRange();
    
    if (domRange) {
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(domRange);
      this.update();
    } else {
      console.error("Failed to create range", { start, end });
    }
  }

  update = () => {
    const range = document.getSelection()?.getRangeAt(0);
    const previousSelection = this.#selection;
    
    if (range.intersectsNode(this.contentElement)) {
      this.#selection = Selection.fromDOMRange(range, this.contentElement);
      this.#selectionText = this.#document.content.slice(this.start, this.end);
    }
    
    if (!this.#selection.isEqual(previousSelection)) {
      dispatchEvent(this.element, "house-md:selectionchange", {
        start: this.start,
        end: this.end
      });
    }
  };

  get start() {
    return this.#selection.start;
  }

  get end() {
    return this.#selection.end;
  }

  get element() {
    return this.#document.element;
  }

  get contentElement() {
    return this.#document.contentElement;
  }

  get isEmpty() {
    return this.start === this.end;
  }

  get isMultiline() {
    return this.current().selection.includes("\n");
  }

  get isBold() {
    return this.#isInElement("strong");
  }

  get isItalic() {
    return this.#isInElement("em");
  }

  get isStrikethrough() {
    return this.#isInElement("s");
  }

  get isLink() {
    return this.#isInElement(".link");
  }

  get isCode() {
    return this.#isInElement(".code");
  }

  get isQuote() {
    return this.#isInElement(".quote");
  }

  get isBulletList() {
    return this.#isInElement(".ul-li");
  }

  get isNumberList() {
    return this.#isInElement(".ol-li");
  }

  #isInElement(selector) {
    let element = window.getSelection().getRangeAt(0).endContainer;
    
    if (element.nodeType === Node.TEXT_NODE) {
      element = element.parentElement;
    }
    
    if (this.contentElement.contains(element)) {
      return !!element.closest(selector);
    }
  }
}

class History {
  static saveInterval = 1000;

  constructor(maxSize = 500) {
    this.maxSize = maxSize;
    this.undoStack = [];
    this.redoStack = [];
  }

  undo(currentState) {
    const state = this.undoStack.pop();
    if (state) {
      this.redoStack.push(currentState);
      return state;
    }
    return {};
  }

  redo(currentState) {
    const state = this.redoStack.pop();
    if (state) {
      this.undoStack.push(currentState);
      return state;
    }
    return {};
  }

  add = throttle((state) => {
    this.undoStack.push(state);
    this.redoStack = [];
    if (this.undoStack.length > this.maxSize) {
      this.undoStack.shift();
    }
  });
}

function throttle(func) {
  let timeout;
  return (...args) => {
    if (!timeout) {
      func(...args);
      timeout = setTimeout(() => {
        timeout = null;
      }, History.saveInterval);
    }
  };
}

function renderMarkdown(text) {
  let result = text;
  
  // Escape HTML
  result = escapeHtml(result);
  
  // Process inline formatting
  result = processInlineFormatting(result);
  
  // Process block elements
  result = processBlockElements(result);
  
  // Process horizontal rules
  result = processHorizontalRules(result);
  
  // Process links and images
  result = processLinks(result);
  result = processImages(result);
  result = processCode(result);
  result = processComments(result);
  
  return result;
}

function escapeHtml(text) {
  text = text.replaceAll(/&/g, "&amp;");
  text = text.replaceAll(/</g, "&lt;");
  text = text.replaceAll(/>/g, "&gt;");
  text = text.replaceAll(/"/g, "&quot;");
  text = text.replaceAll(/'/g, "&#039;");
  return text;
}

function processInlineFormatting(text) {
  // Bold and italic
  text = processBoldItalic(text);
  text = processBold(text);
  text = processItalic(text);
  text = processStrikethrough(text);
  text = processHighlight(text);
  
  return text;
}

function processBoldItalic(text) {
  text = text.replaceAll(/(?<!\*)\*\*\*([^*]+)\*\*\*(?!\*)/gm, "<strong><em>***$1***</em></strong>");
  text = text.replaceAll(/(?<!_)___([^_]+)___(?!_)/gm, "<strong><em>___$1___</em></strong>");
  return text;
}

function processBold(text) {
  text = text.replaceAll(/(?<!\*)\*\*([^*]+)\*\*(?!\*)/gm, "<strong>**$1**</strong>");
  text = text.replaceAll(/(?<!_)__([^_]+)__(?!_)/gm, "<strong>__$1__</strong>");
  return text;
}

function processItalic(text) {
  text = text.replaceAll(/(?<!\*)\*([^*]+)\*(?!\*)/gm, "<em>*$1*</em>");
  text = text.replaceAll(/(?<!_)_([^_]+)_(?!_)/gm, "<em>_$1_</em>");
  return text;
}

function processStrikethrough(text) {
  return text.replaceAll(/~~(.*)?~~/gm, "<s>~~$1~~</s>");
}

function processHighlight(text) {
  return text.replaceAll(/==(.*?)==/gm, "<mark>==$1==</mark>");
}

function processBlockElements(text) {
  text = processHeadings(text);
  text = processNumberedLists(text);
  text = processBulletLists(text);
  text = processBlockquotes(text);
  
  return text;
}

function processHeadings(text) {
  text = text.replaceAll(/^# (.*)$/gm, '<span class="h1"># $1</span>');
  text = text.replaceAll(/^## (.*)$/gm, '<span class="h2">## $1</span>');
  text = text.replaceAll(/^### (.*)$/gm, '<span class="h3">### $1</span>');
  text = text.replaceAll(/^#### (.*)$/gm, '<span class="h4">#### $1</span>');
  text = text.replaceAll(/^##### (.*)$/gm, '<span class="h5">##### $1</span>');
  text = text.replaceAll(/^###### (.*)$/gm, '<span class="h6">###### $1</span>');
  return text;
}

function processNumberedLists(text) {
  return text.replaceAll(/^(\d+\.\s.*)$/gm, '<span class="ol-li">$1</span>');
}

function processBulletLists(text) {
  return text.replaceAll(/^(-\s.*)$/gm, '<span class="ul-li">$1</span>');
}

function processBlockquotes(text) {
  return text.replaceAll(/^&gt;(.*)$/gm, '<span class="quote">>$1</span>');
}

function processHorizontalRules(text) {
  return text.replaceAll(/\n---\n/gm, '\n<span class="hr">---</span>\n');
}

function processLinks(text) {
  return text.replaceAll(/(?<!!)\[(.*?)\]\((.*?)\)/gm, '<span class="link">[$1]($2)</span>');
}

function processImages(text) {
  return text.replaceAll(/!\[(.*?)\]\((.*?)\)/gm, '<span class="img">$&</span>');
}

function processCode(text) {
  text = text.replaceAll(/^```(.*?)```$/gms, '<span class="code">```$1```</span>');
  text = text.replaceAll(/([^`])`([^`]+)`([^`])/gm, '$1<span class="code">`$2`</span>$3');
  return text;
}

function processComments(text) {
  return text.replaceAll(/&lt;!--(.*?)--&gt;/gm, '<span class="comment">&lt;!--$1--&gt;</span>');
}

class Document {
  constructor(content, element) {
    this.content = content;
    this.element = element;
    this.selection = new SelectionManager(this);
    this.history = new History();
  }

  select(start, end) {
    this.selection.select({ start, end });
  }

  insertText(text) {
    this.replaceText(text, this.currentSelection.start, this.currentSelection.end);
  }

  replaceText(text, start, end) {
    const beforeText = this.content.slice(0, start);
    const newContent = `${beforeText}${text}${this.content.slice(end)}`;
    const newSelection = {
      start: beforeText.length + text.length,
      end: beforeText.length + text.length
    };
    
    this.#saveToHistory();
    this.#updateContent(newContent, newSelection);
  }

  insertParagraph(start, end) {
    this.select(start, end);
    
    if (this.selection.isBulletList) {
      this.#insertBulletListItem();
    } else if (this.selection.isNumberList) {
      this.#insertNumberedListItem();
    } else {
      this.replaceText("\n", start, end);
    }
  }

  insertLink(title, url, prefix = "") {
    const { start, end } = this.currentSelection;
    const linkText = ` ${prefix}[${title}](${url}) `;
    this.replaceText(linkText, start, end);
    this.selection.select({
      start: start + linkText.length,
      end: start + linkText.length
    });
  }

  insertFile(title, url, mimeType) {
    if (mimeType.startsWith("image/")) {
      this.insertImage(title, url);
    } else {
      this.insertLink(title, url);
    }
  }

  insertImage(title, url) {
    this.insertLink(title, url, "!");
  }

  deleteText(start, end) {
    this.replaceText("", Math.max(start, 0), end);
  }

  deleteCurrentLine() {
    const { start, end } = this.currentLine;
    this.deleteText(start, end);
  }

  toggleBold() {
    this.#toggleFormatting(this.selection.isBold, "**");
  }

  toggleItalic() {
    this.#toggleFormatting(this.selection.isItalic, "_");
  }

  toggleStrikethrough() {
    this.#toggleFormatting(this.selection.isStrikethrough, "~~");
  }

  toggleCode() {
    const [prefix, suffix] = this.selection.isMultiline 
      ? ["```\n", "\n```"] 
      : ["`", "`"];
    this.#toggleFormatting(this.selection.isCode, prefix, suffix);
  }

  toggleLink() {
    if (this.selection.isLink) {
      this.#removeLink();
    } else {
      this.#addLink();
    }
  }

  toggleQuote() {
    if (this.selection.isQuote) {
      this.#removeLinePrefix("> ");
    } else {
      this.#addLinePrefix("> ");
    }
  }

  toggleBulletList() {
    if (this.selection.isBulletList) {
      this.#removeLinePrefix("- ");
    } else {
      this.#addLinePrefix("- ");
    }
  }

  toggleNumberList() {
    if (this.selection.isNumberList) {
      this.#removeLinePrefix(/\d+\. /);
    } else {
      this.#addLinePrefix(`${this.#getLastListNumber + 1}. `);
    }
  }

  undo() {
    const { content, start, end } = this.history.undo(this.#getCurrentState);
    if (isString(content)) {
      this.#updateContent(content, { start, end });
    }
  }

  redo() {
    const { content, start, end } = this.history.redo(this.#getCurrentState);
    if (isString(content)) {
      this.#updateContent(content, { start, end });
    }
  }

  render() {
    this.contentElement.innerHTML = renderMarkdown(this.content) + "<wbr/>";
  }

  get isEmpty() {
    return !this.content.trim();
  }

  get contentElement() {
    return this.element.contentWrapper;
  }

  get currentSelection() {
    return this.selection.current();
  }

  get currentLine() {
    return this.selection.currentLine();
  }

  #toggleFormatting(isActive, prefix, suffix = prefix) {
    if (isActive) {
      this.#removeFormatting(prefix, suffix);
    } else {
      this.#addFormatting(prefix, suffix);
    }
  }

  #addFormatting(prefix, suffix = prefix) {
    const { start, end, selection } = this.currentSelection;
    const formattedText = `${prefix}${selection}${suffix}`;
    this.replaceText(formattedText, start, end);
    this.selection.select({
      start,
      end: start + selection.length + prefix.length + suffix.length
    });
  }

  #removeFormatting(prefix, suffix = prefix) {
    const { start, end, selection } = this.currentSelection;
    
    if (selection.startsWith(prefix) && selection.endsWith(suffix)) {
      this.replaceText("", end - suffix.length, end);
      this.replaceText("", start, start + prefix.length);
      this.selection.select({
        start,
        end: end - prefix.length - suffix.length
      });
    }
  }

  #addLink() {
    const { start, end, selection } = this.currentSelection;
    const isEmpty = this.selection.isEmpty;
    const linkText = isEmpty ? "title" : selection;
    
    this.replaceText(`[${linkText}](url)`, start, end);
    
    if (isEmpty) {
      this.selection.select({
        start: start + 1,
        end: start + linkText.length + 1
      });
    } else {
      this.selection.select({
        start: start + selection.length + 3,
        end: start + selection.length + 6
      });
    }
  }

  #removeLink() {
    const { start, end, selection } = this.currentSelection;
    const linkText = selection.replace(/\[(.*)\]\(.*\)/, "$1");
    this.replaceText(linkText, start, end);
  }

  #insertBulletListItem() {
    if (this.#getCurrentLineContent.match(/^-\s+$/)) {
      this.deleteCurrentLine();
    } else {
      this.replaceText("\n", this.currentSelection.end, this.currentSelection.end);
      this.replaceText("- ", this.currentSelection.end + 1, this.currentSelection.end + 1);
    }
  }

  #insertNumberedListItem() {
    if (this.#getCurrentLineContent.match(/^\d+\.\s+$/)) {
      this.deleteCurrentLine();
    } else {
      this.replaceText("\n", this.currentSelection.end, this.currentSelection.end);
      this.replaceText(`${this.#getLastListNumber + 1}. `, this.currentSelection.end + 1, this.currentSelection.end + 1);
    }
  }

  #addLinePrefix(prefix) {
    const { start, end } = this.currentSelection;
    const line = this.currentLine;
    this.replaceText(prefix, line.start, line.start);
    this.selection.select({
      start: start + prefix.length,
      end: end + prefix.length
    });
  }

  #removeLinePrefix(prefix) {
    const { start, end } = this.currentSelection;
    const line = this.currentLine;
    
    if (prefix instanceof RegExp) {
      const match = line.content.match(prefix);
      if (!match) return;
      prefix = match[0];
    }
    
    if (line.content.startsWith(prefix)) {
      this.deleteText(line.start, line.start + prefix.length);
      this.selection.select({
        start: start - prefix.length,
        end: end - prefix.length
      });
    }
  }

  #saveToHistory() {
    this.history.add(this.#getCurrentState);
  }

  #updateContent(content, selection) {
    const previousContent = this.content;
    this.content = content;
    this.element.value = content;
    this.selection.select(selection);
    dispatchEvent(this.element, "house-md:change", {
      previousContent,
      newContent: content
    });
  }

  get #getCurrentState() {
    const { start, end } = this.currentSelection;
    return {
      content: this.content,
      start,
      end
    };
  }

  get #getCurrentLineContent() {
    return this.currentLine.content;
  }

  get #getLastListNumber() {
    const previousLine = this.selection.previousLine().content;
    const match = previousLine.match(/^(\d+). /);
    return match ? parseInt(match[1]) : 0;
  }
}

class HtmlToMarkdown {
  #htmlContent;

  constructor(htmlContent) {
    this.#htmlContent = htmlContent;
  }

  asPlainText() {
    const parser = new window.DOMParser();
    const doc = parser.parseFromString(this.#htmlContent, "text/html");
    return this.#extractText(doc.body).trim();
  }

  #extractText(node) {
    if (node.nodeType === Node.TEXT_NODE) {
      return node.nodeValue;
    }
    
    return Array.from(node.childNodes).map((child, index) => {
      const isBlockElement = this.#isBlockElement(child);
      const previousIsBlockElement = index > 0 && this.#isBlockElement(node.childNodes[index - 1]);
      const separator = (isBlockElement && previousIsBlockElement) ? "\n\n" : "";
      
      return separator + this.#extractText(child);
    }).join("");
  }

  #isBlockElement(node) {
    const blockElements = ["BR", "DIV", "H1", "H2", "H3", "H4", "H5", "H6", "LI", "P", "TR"];
    return blockElements.includes(node.tagName);
  }
}

class InputHandler {
  constructor(document) {
    this.document = document;
  }

  handleInput(event, contentElement) {
    event.preventDefault();
    
    const handler = this[`${event.inputType}Handler`];
    if (handler) {
      const range = event.getTargetRanges()[0];
      const { start, end } = Selection.fromDOMRange(range, contentElement);
      handler.call(this, event, start, end);
    } else {
      console.error("Not handling:", event.inputType);
    }
  }

  insertTextHandler(event, start, end) {
    this.#handleTextInsertion(event, start, end);
  }

  insertCompositionTextHandler(event, start, end) {
    this.#handleTextInsertion(event, start, end);
  }

  insertParagraphHandler(event, start, end) {
    this.document.insertParagraph(start, end);
  }

  insertLinkHandler(event, start, end) {
    this.#handleTextInsertion(event, start, end);
  }

  insertFromYankHandler(event, start, end) {
    this.#handleTextInsertion(event, start, end);
  }

  insertFromDropHandler(event, start, end) {
    this.#handleTextInsertion(event, start, end);
  }

  insertFromPasteAsQuotationHandler(event, start, end) {
    const plainText = event.dataTransfer.getData("text/plain");
    this.document.replaceText(`> ${plainText}`, start, end);
  }

  insertTransposeHandler(event, start, end) {
    this.#handleTextInsertion(event, start, end);
  }

  insertReplacementTextHandler(event, start, end) {
    this.#handleTextInsertion(event, start, end);
  }

  insertFromPasteHandler(event, start, end) {
    this.#handleTextInsertion(event, start, end);
  }

  deleteContentBackwardHandler(event, start, end) {
    this.document.deleteText(start, end);
  }

  deleteByCutHandler(event, start, end) {
    this.document.deleteText(start, end);
  }

  deleteWordBackwardHandler(event, start, end) {
    this.document.deleteText(start, end);
  }

  deleteWordForwardHandler(event, start, end) {
    this.document.deleteText(start, end);
  }

  deleteSoftLineBackwardHandler(event, start, end) {
    this.document.deleteText(start, end);
  }

  deleteSoftLineForwardHandler(event, start, end) {
    this.document.deleteText(start, end);
  }

  deleteEntireSoftLineHandler(event, start, end) {
    this.document.deleteText(start, end);
  }

  deleteHardLineBackwardHandler(event, start, end) {
    this.document.deleteText(start, end);
  }

  deleteHardLineForwardHandler(event, start, end) {
    this.document.deleteText(start, end);
  }

  deleteByDragHandler(event, start, end) {
    this.document.deleteText(start, end);
  }

  deleteContentHandler(event, start, end) {
    this.document.deleteText(start, end);
  }

  deleteContentForwardHandler(event, start, end) {
    this.document.deleteText(start, end);
  }

  #handleTextInsertion(event, start, end) {
    let text;
    
    if (event.data) {
      text = event.data;
    } else {
      const htmlData = event.dataTransfer.getData("text/html");
      text = htmlData 
        ? new HtmlToMarkdown(htmlData).asPlainText() 
        : event.dataTransfer.getData("text/plain");
    }
    
    this.document.replaceText(text, start, end);
  }
}

class FileUpload {
  constructor(element, file) {
    this.element = element.closest("house-md");
    this.file = file;
  }

  upload() {
    if (dispatchEvent(this.element, "house-md:before-upload", { file: this.file })) {
      const uploadElement = document.createElement("house-md-upload");
      uploadElement.file = this.file;
      uploadElement.uploadsURL = this.#getUploadsURL;
      this.element.appendChild(uploadElement);
    }
  }

  get #getUploadsURL() {
    return this.element.dataset.uploadsUrl || 
           document.head.querySelector("meta[name=house-uploads-url]")?.content || 
           "/uploads";
  }
}

class ActionHandler {
  constructor(document) {
    this.document = document;
  }

  handleAction(action, data) {
    const handler = this[action];
    if (handler) {
      handler.call(this, data);
    } else {
      console.error("Not handling:", action);
    }
  }

  bold() {
    this.document.toggleBold();
  }

  italic() {
    this.document.toggleItalic();
  }

  strikethrough() {
    this.document.toggleStrikethrough();
  }

  quote() {
    this.document.toggleQuote();
  }

  code() {
    this.document.toggleCode();
  }

  link() {
    this.document.toggleLink();
  }

  bulletList() {
    this.document.toggleBulletList();
  }

  numberList() {
    this.document.toggleNumberList();
  }

  undo() {
    this.document.undo();
  }

  redo() {
    this.document.redo();
  }

  uploadFile({ file }) {
    new FileUpload(this.document.element, file).upload();
  }
}

class DragDropHandler {
  constructor(element) {
    this.element = element.closest("house-md");
  }

  handleDragOver(event) {
    event.preventDefault();
  }

  async handleDrop(event) {
    event.preventDefault();
    
    for (const item of event.dataTransfer.items) {
      if (item.kind === "file") {
        new FileUpload(this.element, item.getAsFile()).upload();
      }
    }
  }
}

const keyboardShortcuts = {
  "Ctrl+B": "bold",
  "Ctrl+I": "italic", 
  "Ctrl+S": "strikethrough",
  "Ctrl+Z": "undo",
  "Ctrl+Shift+Z": "redo"
};

class Editor extends HTMLElement {
  static formAssociated = true;

  constructor() {
    super();
    this.internals = this.attachInternals();
    this.internals.ariaRole = "textbox";
  }

  connectedCallback() {
    const initialContent = this.querySelector(".house-md-content")?.textContent || this.textContent;
    this.document = new Document(initialContent, this);
    
    this.#setupDOM();
    this.#setupEventListeners();
    
    this.inputHandler = new InputHandler(this.document);
    this.actionHandler = new ActionHandler(this.document);
    this.dropAndDropHandler = new DragDropHandler(this);
    
    if (this.autofocus) {
      this.focus();
    }
    
    this.setAttribute("initialized", "");
    this.value = initialContent;
  }

  disconnectedCallback() {
    this.#removeEventListeners();
  }

  validate = (event) => {
    if (this.required && this.document.isEmpty) {
      event.preventDefault();
      this.internals.setValidity(
        { valueMissing: true },
        "This field is required.",
        this.element
      );
      this.focus();
    } else {
      this.internals.setValidity({});
    }
  };

  render() {
    this.document.render();
  }

  focus() {
    this.contentWrapper.focus();
  }

  get required() {
    return this.hasAttribute("required");
  }

  set required(value) {
    if (value) {
      this.setAttribute("required", "");
    } else {
      this.removeAttribute("required");
    }
  }

  get autofocus() {
    return this.hasAttribute("autofocus");
  }

  set autofocus(value) {
    if (value) {
      this.setAttribute("autofocus", "");
    } else {
      this.removeAttribute("autofocus");
    }
  }

  get value() {
    return this.document.content;
  }

  set value(content) {
    this.document.content = content;
    this.internals.setFormValue(content);
    this.internals.setValidity({});
    this.render();
  }

  get form() {
    return this.internals.form;
  }

  #setupDOM() {
    this.textContent = "";
    this.toolbar = this.#getOrCreateToolbar();
    this.contentWrapper = document.createElement("div");
    this.contentWrapper.classList.add("house-md-content");
    this.contentWrapper.setAttribute("contenteditable", true);
    this.append(this.contentWrapper);
    
    if (!this.getAttribute("tabindex")) {
      this.contentWrapper.setAttribute("tabindex", 0);
    }
  }

  #getOrCreateToolbar() {
    if (this.getAttribute("toolbar")) {
      return document.getElementById(this.getAttribute("toolbar"));
    } else {
      const toolbar = document.createElement("house-md-toolbar");
      this.prepend(toolbar);
      return toolbar;
    }
  }

  #setupEventListeners() {
    this.addEventListener("beforeinput", this.#handleBeforeInput);
    this.addEventListener("keydown", this.#handleKeyDown);
    this.addEventListener("dragover", this.#handleDragOver);
    this.addEventListener("drop", this.#handleDrop);
    this.toolbar.addEventListener("house-md:toolbar-action", this.#handleToolbarAction);
    document.addEventListener("selectionchange", this.#handleSelectionChange);
    this.internals.form.addEventListener("submit", this.validate);
  }

  #removeEventListeners() {
    this.removeEventListener("beforeinput", this.#handleBeforeInput);
    this.removeEventListener("keydown", this.#handleKeyDown);
    this.removeEventListener("dragover", this.#handleDragOver);
    this.removeEventListener("drop", this.#handleDrop);
    this.toolbar.removeEventListener("house-md:toolbar-action", this.#handleToolbarAction);
    document.removeEventListener("selectionchange", this.#handleSelectionChange);
    this.internals.form.removeEventListener("submit", this.validate);
  }

  #handleBeforeInput = (event) => {
    this.inputHandler.handleInput(event, this.contentWrapper);
  };

  #handleKeyDown(event) {
    const action = getKeyboardShortcutAction(event);
    if (action) {
      event.preventDefault();
      this.actionHandler.handleAction(action);
    }
  }

  #handleDragOver = (event) => {
    this.dropAndDropHandler.handleDragOver(event);
  };

  #handleDrop = (event) => {
    this.dropAndDropHandler.handleDrop(event);
  };

  #handleToolbarAction = ({ detail }) => {
    this.actionHandler.handleAction(detail.houseMdAction, detail);
  };

  #handleSelectionChange = () => {
    this.document.selection.update();
  };
}

function getKeyboardShortcutAction(event) {
  const shortcut = getKeyboardShortcut(event);
  return keyboardShortcuts[shortcut];
}

function getKeyboardShortcut(event) {
  const keys = [];
  
  if (event.metaKey || event.ctrlKey) {
    keys.push("Ctrl");
  }
  if (event.altKey) {
    keys.push("Alt");
  }
  if (event.shiftKey) {
    keys.push("Shift");
  }
  
  keys.push(event.key.toUpperCase());
  
  return keys.join("+");
}

customElements.define("house-md", Editor);

class Upload extends HTMLElement {
  #file;
  #uploadsURL;
  #errorMessage;

  constructor() {
    super();
    this.percentComplete = 0;
    this.status = "pending";
  }

  connectedCallback() {
    this.#render();
    this.#startUpload();
    this.addEventListener("click", this.#handleClick);
  }

  disconnectedCallback() {
    this.removeEventListener("click", this.#handleClick);
  }

  async #startUpload() {
    const formData = new FormData();
    formData.append("file", this.file);
    
    if (this.csrfParamName) {
      formData.append(this.csrfParamName, this.csrfToken);
    }
    
    this.xhr = new XMLHttpRequest();
    this.xhr.open("POST", this.uploadsURL, true);
    this.xhr.upload.onprogress = this.#handleProgress;
    this.xhr.onload = this.#handleLoad;
    this.xhr.onerror = this.#handleError;
    this.xhr.onabort = this.#handleAbort;
    this.xhr.send(formData);
    
    this.status = "uploading";
    this.#render();
  }

  #render() {
    this.setAttribute("status", this.status);
    this.innerHTML = `
      ${this.#renderCloseButton()}
      ${this.#renderFileName()}
      ${this.#renderProgressBar()}
      ${this.#renderError()}
    `;
  }

  #renderCloseButton() {
    return this.status === "failed" 
      ? "<button data-md-action='close' class='md-close' aria-label='Close'></button>"
      : "";
  }

  #renderFileName() {
    return `<div class="md-file">${this.file.name}</div>`;
  }

  #renderProgressBar() {
    return `<progress aria-label="Uploading fileâ€¦" class="md-progress-bar" max="100" value="${this.percentComplete}">${this.percentComplete}%</progress>`;
  }

  #renderError() {
    return this.#errorMessage 
      ? `<div class="md-error">${this.#errorMessage}</div>`
      : "";
  }

  #handleProgress = (event) => {
    if (event.lengthComputable) {
      this.percentComplete = (event.loaded / event.total) * 100;
    }
    this.#render();
  };

  #handleLoad = async () => {
    if (this.xhr.status >= 400) {
      this.status = "failed";
      this.#errorMessage = this.xhr.responseText || "Upload failed";
    } else {
      const response = JSON.parse(this.xhr.responseText);
      await this.document.insertFile(response.fileName, response.fileUrl, response.mimetype);
      this.status = "complete";
      this.#autoRemove();
    }
    this.#render();
  };

  #handleError = () => {
    this.status = "failed";
    this.#render();
  };

  #handleAbort = () => {
    this.status = "aborted";
    this.#render();
  };

  #handleClick = (event) => {
    if (event.target.matches("[data-md-action=close]")) {
      this.remove();
    }
  };

  async #autoRemove(delay = 500) {
    await sleep(delay);
    this.remove();
  }

  get document() {
    return this.closest("house-md").document;
  }

  get file() {
    return this.#file;
  }

  set file(value) {
    this.#file = value;
  }

  get uploadsURL() {
    return this.#uploadsURL;
  }

  set uploadsURL(value) {
    this.#uploadsURL = value;
  }

  get csrfParamName() {
    return document.head.querySelector("meta[name=csrf-param]")?.content;
  }

  get csrfToken() {
    return document.head.querySelector("meta[name=csrf-token]")?.content;
  }
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

customElements.define("house-md-upload", Upload);

export {
  Document,
  Editor,
  History,
  SelectionManager as Selection,
  Toolbar,
  Upload
};
